"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const t=t=>{let e,s;return function(...r){return s||(e=t(...r),s=!0),e}},e=t=>{if(!t)return!0;if(Array.isArray(t)){if(0===t.length)return!0}else if("object"==typeof t&&0===Object.keys(t).length)return!0;return!1},s=t=>t[0],r=(t,e)=>{if(null==t||!t.length)throw new RangeError("empty arguments");if(3===t.length){if(!e)return t}else if(1===t.length){const e=s(t);"string"==typeof e?t.push(",",{}):Array.isArray(e)?(t.unshift(null),t.push({})):"object"==typeof e&&t.unshift(null,",")}else if(2===t.length)"string"==typeof t[0]&&t[1]instanceof RegExp||"string"==typeof t[1]||Array.isArray(t[1])?t.push({}):t.unshift(null);else if(t.length>3)throw new RangeError("Too much arguments passed to splitSmartly function!!!");return e&&(t[2]={...t[2],...e}),t};let i;const n=(t,r)=>({brackets:[],mentions:[],ignoreInsideQuotes:!0,includeSeparatorMode:"NONE",ignoreCase:!0,trimResult:!0,trimSeparators:!1,check:void 0,defaultBrackets:[["(",")"],["[","]"],["{","}"]],...r,separators:t,init(){if(Array.isArray(this.mentions)||"string"==typeof this.mentions){const t=[this.mentions].flat().filter(Boolean).reduce(((t,e)=>(t[this.ignoreCase?e.toUpperCase():e]=e,t)),{});this.mentions=!e(t)&&t}return this.createBracketsMap().createBracketsSearch().createSeparatorsSearch()},merge(t){return t?(t={...this,...t},["brackets","mentions"].some((e=>e in t))&&t.init(),t):this},arrayToPattern:t=>function(t){return null!=i||(i=new Set(".{}[]^()+*?\\/$|".split(""))),t.map((t=>t instanceof RegExp?t.source:t.split("").map((t=>i.has(t)?"\\"+t:t)).join(""))).join("|")}(t),createRegExp:t=>RegExp(t,"g"),createBracketsMap(){let{brackets:t=[],ignoreInsideQuotes:e}=this;return!0===t?t=this.defaultBrackets:"object"!=typeof t||Array.isArray(t)?"string"==typeof t&&(t=t.split(",").map((t=>{let e=t.trim().split(" ");if(2!==e.length){if(2!==s(e).length)throw new Error("open and close parts of brackets should be separated by space symbol");e=s(e).split("")}return e}))):t=Object.entries(t),e&&t.unshift(["'",,,!0],['"',,,!0]),this.bracketsMap=t.reduce(((t,[e,s,...r])=>{1!==r.length||this.searchWithin||r.unshift(void 0);let[i=this.searchWithin&&1,n]=r;return"number"==typeof i&&(i=[i]),t[e]={open:e,ignoreMode:n,searchLevels:i,close:s||e},t}),{}),this},createBracketsSearch(){const t=Object.entries(this.bracketsMap).flatMap((([,{close:t,open:e}])=>t!==e?[e,t]:e)).concat(Object.keys(this.mentions||{})).filter(Boolean),e=this.arrayToPattern(t);return this.bracketsSearch=this.createRegExp(e),this},createSeparatorsSearch(){const{separators:t}=this;if("string"==typeof t||Array.isArray(t)){const e=this.arrayToPattern([t].flat().filter(Boolean));this.separatorSearch=this.createRegExp(e)}else t?(this.separatorSearch=t,this.ignoreCase=t.ignoreCase):this.separatorSearch=/empty/;return this}}.init());class a{constructor(t,e){this.string=t,this.searchSettings=e,this.prepareSearch()}prepareSearch(){const{separatorSearch:t,bracketsSearch:s,indexes:r}=this.searchSettings,i=[r].flat().filter(Boolean);for(const e of[t,s])e.lastIndex=0;Object.assign(this,{brackets:[],pipe:[],currentMentions:[],position:0,isDone:!1,freeArea:{start:0,end:void 0},lastSeparator:void 0,searchString:this.searchSettings.ignoreCase&&!this.searchSettings.separatorSearch.ignoreCase?this.string.toUpperCase():this.string,indexes:!e(i)&&{values:new Set(i),max:Math.max(...i),count:0,hasIndex(){return-Infinity===this.max||this.values.has(this.count++)},isOverMax(){return-Infinity!==this.max&&this.count>this.max}}})}get pipeIsEmpty(){return e(this.pipe)}getMentions(t,e){const s=[],r=[];for(const i of this.currentMentions)i.index>=t&&i.index<e?s.push(i.mention):r.push(i);return[s.length&&s,r]}trimResultText(t){return this.searchSettings.trimResult?t.trim():t}trimSeparatorText(t){return this.searchSettings.trimSeparators?t.trim():t}checkSeparator(e){const{string:s}=this,{check:r,includePositions:i,mentions:n}=this.searchSettings;let{0:a="",index:o=s.length,searchWithinData:h}=null!=e?e:{};const c=a.length,p=h?h.openPosition:this.position;let l=s.substring(p,o);a||(this.isDone=!0),l=this.trimResultText(l),a=this.trimSeparatorText(a);let u,g=h?[h.open,h.close]:a;if(i&&(l={text:l,position:p},g={text:g,position:o,isSeparator:!0}),n){l="string"==typeof l?{text:l}:l;const[t,e]=this.getMentions(p,o);t&&(l.mentions=t,u=e)}if(r&&a){const e=isNaN(this.tempPosition)?p:this.tempPosition;this.tempPosition=o+a.length;const i=this;if(!r({getString:t((()=>i.trimResultText(s.substring(e,o)))),getTextAfter:t((()=>s.substring(o+a.length))),getMentions:t((()=>i.getMentions(e,o)[0])),getSeparator:t((()=>a)),get string(){return this.getString()},get textAfter(){return this.getTextAfter()},get mentions(){return this.getMentions()},get separator(){return this.getSeparator()}}))return[];delete this.tempPosition}return u&&(this.currentMentions=u),this.position=o+c,[l,g,!0]}pushToPipe(t){if(this.indexes){if(!this.indexes.hasIndex())return;this.indexes.isOverMax()&&(this.isDone=!0)}this.pipe.push(t)}addToPipe(t){let[e,s,r]=this.checkSeparator(t);if(!r)return!1;switch(this.searchSettings.includeSeparatorMode){case"SEPARATELY":this.pushToPipe(e),s&&this.pushToPipe(s);break;case"LEFT":this.pushToPipe([e,s]);break;case"RIGHT":!("object"==typeof e?e.text:e)&&!this.lastSeparator||this.pushToPipe([this.lastSeparator,e]),this.lastSeparator=s;break;case"ONLY":s&&this.pushToPipe(s);break;default:this.pushToPipe(e)}return!this.pipeIsEmpty}findBrackets(){const{searchString:t,brackets:s,freeArea:r,searchSettings:i}=this,{bracketsSearch:n,separatorSearch:a,searchWithin:o}=i,h=o?()=>this.pipeIsEmpty:()=>!r.end;for(;h();){var c;const h=n.exec(t);if(!h){if(o||isNaN(r.start))return!1;r.end=t.length-1;continue}const l=h[0],{close:u,ignoreMode:g,searchLevels:f}=(p=s)[p.length-1]||{};let d;switch((l===u?1:g&&4)||(d=i.bracketsMap[l])&&2||(null==(c=i.mentions)?void 0:c[l])&&3){case 1:const t=s.pop();o?(!0===f||f.includes(s.length+1))&&this.addToPipe(Object.assign(h,{searchWithinData:t})):e(s)&&(r.start=h.index,a&&a.lastIndex<r.start&&(a.lastIndex=r.start));break;case 2:s.push({...d,openPosition:h.index+l.length}),1!==s.length||o||(r.end=h.index);break;case 3:this.currentMentions.push({mention:i.mentions[l],index:h.index})}}var p;return!0}findSeparator(t){const{searchString:e,freeArea:s}=this,{separatorSearch:r}=this.searchSettings;let i;for(;!i;){if(t=t||r.exec(e))if(t.index<=s.end){const e=t.index>=s.start&&this.addToPipe(t);if(t=null,!e)continue}else s.start=s.end=void 0;else this.addToPipe();i=!0}return t}getNext(){let t;for(;this.pipeIsEmpty&&!this.isDone;)this.findBrackets()?this.searchSettings.searchWithin||(t=this.findSeparator(t)):this.isDone=!0;return this.pipeIsEmpty?null:this.pipe.shift()}getAll(){return[...this]}getRest(){const t=[];let e;for(;null!==(e=this.getNext());)t.push(e);return t}*[Symbol.iterator](){this.prepareSearch();const t=this;let e;do{e=t.getNext(),null!==e&&(yield e)}while(null!==e)}}function o(t,e){const s=this.merge(e);let r=new a(t,s);return"number"==typeof s.indexes?r.getNext():s.returnIterator?r:r.getAll()}const h=t=>{const e=o.bind(t);return Object.assign(e,{getOne(t,s,r={}){if(isNaN(s))throw new Error("second parameter of `getOne` function should be index");return e(t,{...r,indexes:s})},getFirst:(t,s={})=>e(t,{...s,indexes:0}),getIndexes(t,s,r={}){if(!Array.isArray(s))throw new Error("second parameter of `getOne` function should be array of indexes");return e(t,{...r,indexes:s})},getIterator:(t,s={})=>e(t,{...s,returnIterator:!0})})};var c,p;function l(...t){let[e,s,i]=r(t);const a=n(s,i),o=h(a);return null!==e?o(e):o}exports.EnumIncludeSeparatorMode=void 0,(c=exports.EnumIncludeSeparatorMode||(exports.EnumIncludeSeparatorMode={})).INCLUDE_SEPARATOR_NONE="NONE",c.INCLUDE_SEPARATOR_SEPARATELY="SEPARATELY",c.INCLUDE_SEPARATOR_LEFT="LEFT",c.INCLUDE_SEPARATOR_RIGHT="RIGHT",c.INCLUDE_SEPARATOR_ONLY="ONLY",function(t){t[t.ACTION_CLOSE=1]="ACTION_CLOSE",t[t.ACTION_OPEN=2]="ACTION_OPEN",t[t.ACTION_ADD_FRAGMENT=3]="ACTION_ADD_FRAGMENT",t[t.ACTION_NULL=4]="ACTION_NULL"}(p||(p={})),l.searchWithin=(...t)=>(1===t.length&&("string"==typeof t[0]?t.push(null,{}):t.unshift(null)),"object"==typeof t[1]&&t[1].brackets||(t[1]={brackets:t[1]}),t.splice(1,0,null),l(...r(t,{searchWithin:!0}))),l.search=(...t)=>l(...r(t,{includeSeparatorMode:"ONLY"})),exports.SearchResults=a,exports.createSplitFunction=h,exports.default=l,exports.splitSmartly=l;
//# sourceMappingURL=split-smartly.cjs.production.min.js.map
